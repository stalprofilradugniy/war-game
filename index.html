<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Special Forces Maze</title>
    <style>
        /* ... (стили остаются без изменений) ... */
    </style>
</head>
<body>
    <h1>Special Forces Maze</h1>
    <div id="game-container"></div>
    <div id="status">Health: 200</div>
    <div id="message"></div>

    <script>
        class GameObject {
            constructor(x, y, symbol, health, damage) {
                this.x = x;
                this.y = y;
                this.symbol = symbol;
                this.health = health;
                this.damage = damage;
            }
        }

        class Player extends GameObject {
            constructor(x, y) {
                super(x, y, 'P', 200, 30);
            }
        }

        class Enemy extends GameObject {
            constructor(x, y) {
                super(x, y, 'T', 80, 15);
            }
        }

        class Portal {
            constructor(x, y, pairId) {
                this.x = x;
                this.y = y;
                this.symbol = 'O';
                this.pairId = pairId;
            }
        }

        class Game {
            constructor() {
                this.width = 25;
                this.height = 15;
                this.map = [];
                this.portals = [];
                this.player = null;
                this.enemies = [];
                this.isPlayerTurn = true;
                this.attemptCount = 0; // Счетчик попыток генерации
                
                this.initializeGame();
            }

            initializeGame() {
                this.attemptCount++;
                if(this.attemptCount > 10) {
                    alert("Failed to generate valid maze after 10 attempts!");
                    return;
                }

                this.generateMaze();
                this.placePortals();
                this.placePlayer();
                
                if(!this.isMazeValid()) {
                    this.initializeGame();
                    return;
                }

                this.placeEnemies();
                this.drawMap();
                this.setupControls();
            }

            generateMaze() {
                // Генерация лабиринта с гарантированным стартом в (1,1)
                this.map = Array(this.height).fill().map((_, y) => 
                    Array(this.width).fill().map((_, x) => 
                        (x % 2 === 0 || y % 2 === 0) ? '#' : '.'));

                const stack = [];
                const start = {x: 1, y: 1};
                stack.push(start);

                while(stack.length > 0) {
                    const current = stack[stack.length-1];
                    const neighbors = this.getUnvisitedNeighbors(current.x, current.y);
                    
                    if(neighbors.length === 0) {
                        stack.pop();
                        continue;
                    }

                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const wall = {
                        x: current.x + (next.x - current.x)/2,
                        y: current.y + (next.y - current.y)/2
                    };
                    
                    this.map[wall.y][wall.x] = '.';
                    this.map[next.y][next.x] = '.';
                    stack.push(next);
                }

                // Гарантируем, что стартовая позиция свободна
                this.map[1][1] = '.';
            }

            placePlayer() {
                // Проверяем и исправляем стартовую позицию
                if(this.map[1][1] === '.') {
                    this.player = new Player(1, 1);
                } else {
                    const freeCells = this.getFreeCells();
                    if(freeCells.length === 0) return;
                    const [x, y] = freeCells[0];
                    this.player = new Player(x, y);
                }
            }

            isMazeValid() {
                if(!this.player) return false;
                
                const visited = Array(this.height).fill().map(() => 
                    Array(this.width).fill(false));
                const queue = [[this.player.x, this.player.y]];
                let count = 0;

                while(queue.length > 0) {
                    const [x, y] = queue.shift();
                    if(visited[y][x]) continue;
                    visited[y][x] = true;
                    count++;

                    const directions = [
                        [1, 0], [-1, 0], [0, 1], [0, -1]
                    ];
                    for(const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if(nx >= 0 && nx < this.width && 
                           ny >= 0 && ny < this.height && 
                           this.map[ny][nx] === '.' && !visited[ny][nx]) {
                            queue.push([nx, ny]);
                        }
                    }
                }

                const totalFree = this.getFreeCells().length;
                return count >= totalFree * 0.95;
            }

            placeEnemies() {
                const freeCells = this.getFreeCells().filter(([x, y]) => 
                    !(x === this.player.x && y === this.player.y));
                
                for(let i = 0; i < 5; i++) {
                    if(freeCells.length === 0) break;
                    const idx = Math.floor(Math.random() * freeCells.length);
                    const [x, y] = freeCells.splice(idx, 1)[0];
                    this.enemies.push(new Enemy(x, y));
                }
            }

            getFreeCells() {
                const cells = [];
                for(let y = 0; y < this.height; y++) {
                    for(let x = 0; x < this.width; x++) {
                        if(this.map[y][x] === '.' && 
                           !this.portals.some(p => p.x === x && p.y === y)) {
                            cells.push([x, y]);
                        }
                    }
                }
                return cells;
            }

            // ... (остальные методы остаются без изменений) ...
        }

        // Запуск игры
        new Game();
    </script>
</body>
</html>
